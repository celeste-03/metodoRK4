{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":""},{"location":"#introduccion","title":"Introducci\u00f3n","text":"<p>Este proyecto documenta el m\u00e9todo de Runge-Kutta de cuarto orden (RK4) para resolver ecuaciones diferenciales ordinarias. En este caso, aplicamos el m\u00e9todo al problema din\u00e1mico de valor inicial:</p> \\[ \\frac{dy}{dt} = f(t, y); \\quad y(t_0) = y_0 \\]"},{"location":"explanation/","title":"Explicaci\u00f3n del M\u00e9todo RK4","text":"<p>El m\u00e9todo RK4 es un m\u00e9todo num\u00e9rico para aproximar soluciones de ecuaciones diferenciales ordinarias. Calcula cuatro inclinaciones intermedias para mejorar la precisi\u00f3n de la soluci\u00f3n en cada paso:</p> \\[ k_1 = h f(t_n, y_n) \\] \\[ k_2 = h f\\left(y_n + \\frac{k_1}{2}, t_n + \\frac{h}{2}\\right) \\] \\[ k_3 = h f\\left(y_n + \\frac{k_2}{2}, t_n + \\frac{h}{2}\\right) \\] \\[ k_4 = h f(y_n + k_3, t_n + h) \\] <p>Finalmente, la soluci\u00f3n en el siguiente paso es:</p> \\[ y_{n}(t_n +h) = y(t) + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4) \\]"},{"location":"reference/","title":"Referencia de Funciones","text":""},{"location":"reference/#dyn_generatort-y","title":"<code>dyn_generator(t, y)</code>","text":"<p>Genera la din\u00e1mica para el sistema dado.</p>"},{"location":"reference/#argumentos","title":"Argumentos","text":"<ul> <li><code>t</code> (float): Tiempo actual.</li> <li><code>y</code> (ndarray): Estado actual del sistema.</li> </ul>"},{"location":"reference/#retorno","title":"Retorno","text":"<ul> <li><code>ndarray</code>: Derivada del estado.</li> </ul>"},{"location":"reference/#ejemplo-de-uso","title":"Ejemplo de uso","text":"<p><code>python dy_dt = dyn_generator(0, np.array([1, 0]))</code></p>"},{"location":"tutorials/","title":"Ejemplo de uso del M\u00e9todo RK4","text":"<p>A continuaci\u00f3n, se muestra un ejemplo de uso del m\u00e9todo RK4 aplicado a la din\u00e1mica del sistema. Utilizamos los datos de <code>stateQuant00</code> y <code>stateQuant11</code> en funci\u00f3n del tiempo.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Definir la matriz identidad\nidentityMatrix = np.array([[1, 0], [0, 1]])\n\n# Operador O\noOper = np.array([[0, 1], [1, 0]])\n\n# Estado inicial\nyInit = np.array([[1, 0], [0, 0]], dtype=complex)\n\n# Funci\u00f3n generadora de din\u00e1mica\ndef dyn_generator(oper, state):\n    return -1*1.0j*(np.dot(oper, state) - np.dot(state, oper))\n\n# Implementaci\u00f3n de Runge-Kutta de cuarto orden\ndef rk4(func, oper, state, h):\n    k_1 = h * func(oper, state)\n    k_2 = h * func(oper, state + k_1 / 2)\n    k_3 = h * func(oper, state + k_2 / 2)\n    k_4 = h * func(oper, state + k_3)\n    return state + (1/6) * (k_1 + 2 * k_2 + 2 * k_3 + k_4)\n\n# Crear el arreglo de tiempos desde 0 hasta 10\ntimes = np.linspace(0, 10, num=100)\n\n# Definir el paso temporal h como la diferencia entre dos tiempos consecutivos\nh = times[1] - times[0]\n\n# Hacer una copia profunda del estado inicial\nyCopy = yInit.copy()\n\n# Definir los arreglos para almacenar las cantidades de estado\nstateQuant00 = np.zeros(times.size)\nstateQuant11 = np.zeros(times.size)\n\n# Ciclo para calcular los valores en cada paso temporal\nfor tt in range(times.size):\n    # Guardar las entradas (0,0) y (1,1) de yInit en los arreglos correspondientes\n    stateQuant00[tt] = yInit[0, 0].real\n    stateQuant11[tt] = yInit[1, 1].real\n\n    # Invoque rk4 operando sobre yInit y asignar el resultado a yN\n    yN = rk4(dyn_generator, oOper, yInit, h)\n\n    # Asignar yN a yInit para la siguiente iteraci\u00f3n\n    yInit = yN\n\n# Ruta para guardar las im\u00e1genes\n\n# Graficar los resultados\nplt.figure(figsize=(10, 6))\nplt.plot(times, stateQuant00, label='Estado (0,0)', linewidth=2.0, color='blue')\nplt.plot(times, stateQuant11, 'x', label='Estado (1,1)', markeredgewidth=2, color='green')\nplt.xlabel('Tiempo')\nplt.ylabel('Estado')\nplt.title('Evoluci\u00f3n del estado con Runge-Kutta 4')\nplt.legend()\nplt.grid(True)\n\n# Guardar la imagen\nplt.savefig(/home/celeste_us/metodoRK4/docs/evolucion_estado_rk4.png)\nplt.show()\n\n# Probar con diferentes valores de h para analizar estabilidad\ncolors = ['green', 'orange', 'magenta', 'blue']  # Colores diferentes para cada h\nh_values = [0.05, 0.1, 0.5, 1.0]\n\nfor i, new_h in enumerate(h_values):\n    yInit = yCopy.copy()\n    stateQuant00 = np.zeros(times.size)\n    stateQuant11 = np.zeros(times.size)\n\n    for tt in range(times.size):\n        stateQuant00[tt] = yInit[0, 0].real\n        stateQuant11[tt] = yInit[1, 1].real\n        yN = rk4(dyn_generator, oOper, yInit, new_h)\n        yInit = yN\n\n    plt.plot(times, stateQuant00, label=f'h={new_h}', color=colors[i])\nplt.xlabel('Tiempo')\nplt.ylabel('Estado')\nplt.title('Evoluci\u00f3n del estado con diferentes valores de h')\nplt.legend()\nplt.grid(True)\n\n# Guardar la imagen\nplt.savefig(/home/celeste_us/metodoRK4/docs/evolucion_estado_diferentes_h.png)\nplt.show()\n</code></pre> <p> </p>"}]}